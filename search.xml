<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Best Efforts 1PC Pattern Implements Distributed Transactions in Spring, without XA</title>
    <url>/posts/2540280255.html</url>
    <content><![CDATA[<h1><span id="简述">简述</span></h1><p>Distributed transactions in Spring, with and without XA一文中描述了在Spring中实现分布式事务的7种处理模式；3种基于XA协议，4种特定场景的非XA协议的模式；</p>
<h1><span id="最大努力一阶段提交模式">最大努力一阶段提交模式</span></h1><p>4种非XA协议模式的第一种是共享事务资源模式（Shared Transaction Resource pattern），其提供了特定场景的多资源事务同步模式；<br>第二种便是本文要说的最大努力一阶段提交提交模式，在共享事务资源模式中，将两个系统的事务使用同一个事务资源的一个事务来管理，从而达到一起成功一起失败的目的；<br><a id="more"></a><br>而在最大努力一阶段提交模式中，不特意控制两个资源在同一个事务中，而是寄希望于其中一个资源的事务管理相当简单，简单到唯一肯能发生错误的就是基础组建发生错误，而非业务处理错误。<br>比如说关系型数据库就不是一个这样的资源，他除了基础组建会发生错误以外，业务上还会发生各种各样的错误情况，比如说主键重复，查不到数据时抛出业务异常等等；<br>从消息系统里接收消息，就是一个符合这种情况的资源，从其接收到消息之后，业务处理成功之后，提交消息事务，在这里，接收消息和提交消息事务这两个操作没有业务逻辑，只有像消息服务器，网络这种基础组件出问题时，才有可能出问题。</p>
<h1><span id="举个例子">举个例子</span></h1><p>在这种情况下，如果我们就直接不管消息系统的提交结果，会怎么样？还是消息驱动的单个数据库更新场景，如果不控制消息系统接收消息的事务，只控制复杂的数据库事务，那么处理过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启消息事务</span><br><span class="line">接受消息</span><br><span class="line">开启数据库事务</span><br><span class="line">更新数据库</span><br><span class="line">提交数据库事务</span><br><span class="line">提交消息事务</span><br></pre></td></tr></table></figure>
<p>如果是开启消息事务或者接收消息，这两个步骤出问题，只可能是基础组件的问题，基础组件恢复之后，重新获取即可，对整个系统没有任何影响<br>如果开启数据库事务、更新数据库或者提交数据库事务出问题，事务回滚，没有提交消息事务，超时之后，消息会被重新接收<br>如果是提交消息事务出问题，这时数据库事务已经提交，但是消息事务提交失败，事务超时时候，消息服务器会将消息重新发送过来；这时，唯一的一个问题来了，同一个消息会被重新处理一遍。解决这个问题的杀手锏就是保证业务服务的幂等，这个做起来非常容易。</p>
<h1><span id="跟kafka有什么关系">跟Kafka有什么关系</span></h1><p>在Kafka Consumer中，接收消息的语义有三种模式，最多一次，最少一次，正好一次，没错，这就是最少一次的情况。</p>
<h1><span id="参考">参考</span></h1><p><a href="https://www.javaworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html" target="_blank" rel="noopener">Distributed transactions in Spring, with and without XA</a><br><a href="http://www.importnew.com/15812.html" target="_blank" rel="noopener">如何实现XA式、非XA式Spring分布式事务</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Transaction</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Transaction</tag>
        <tag>Distributed Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Confluent Platform Quick Start (Docker)</title>
    <url>/posts/1992991654.html</url>
    <content><![CDATA[<h1><span id="问题">问题</span></h1><p>Confluent提供了Kafka的整套生态的docker镜像：<a href="https://github.com/confluentinc/cp-docker-images" target="_blank" rel="noopener">confluentinc/cp-docker-images</a>，并在<a href="https://docs.confluent.io/current/quickstart/ce-docker-quickstart.html" target="_blank" rel="noopener">官方文档 Confluent Platform Quick Start (Docker) </a>中详细的描述了这些镜像的使用方法。<br><a id="more"></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/confluentinc/cp-docker-images</span><br><span class="line">$ <span class="built_in">cd</span> cp-docker-images</span><br><span class="line">$ git checkout 5.1.2-post</span><br><span class="line">$ <span class="built_in">cd</span> examples/cp-all-in-one/</span><br><span class="line">$ docker-compose up -d --build</span><br></pre></td></tr></table></figure>
<p>如果按照上面的步骤，会发现在执行docker-compose up -d –build命令时会出现访问d1i4a15mxbxib1.cloudfront.net，访问不到的情况，是构建confluentinc/ksql-examples:5.1.2镜像时发生的，注意是在构建镜像的阶段发生的，不是在启动镜像的阶段发生的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Building connect</span><br><span class="line">Step 1/3 : FROM confluentinc/cp-kafka-connect:5.1.2</span><br><span class="line">---&gt; a556d728ef1e</span><br><span class="line">Step 2/3 : ENV CONNECT_PLUGIN_PATH=<span class="string">"/usr/share/java,/usr/share/confluent-hub-components"</span></span><br><span class="line">---&gt; Using cache</span><br><span class="line">---&gt; 3fc1228c32fb</span><br><span class="line">Step 3/3 : RUN confluent-hub install --no-prompt confluentinc/kafka-connect-datagen:latest</span><br><span class="line">---&gt; Running <span class="keyword">in</span> 305285df291e</span><br><span class="line">Running <span class="keyword">in</span> a <span class="string">"--no-prompt"</span> mode </span><br><span class="line">Implicit acceptance of the license below:  </span><br><span class="line">Apache License 2.0 </span><br><span class="line">https://www.apache.org/licenses/LICENSE-2.0 </span><br><span class="line">Downloading component Kafka Connect Datagen 0.1.1, provided by Confluent, Inc. from Confluent Hub and installing into /usr/share/confluent-hub-components </span><br><span class="line">java.net.UnknownHostException: d1i4a15mxbxib1.cloudfront.net</span><br></pre></td></tr></table></figure>
<p>通过查看github仓库的issue，<a href="https://github.com/confluentinc/cp-docker-images/issues/654" target="_blank" rel="noopener">Unable to install kafka-connect-datagen:0.1.0 #654</a>，发现这个域名是<a href="https://api.hub.confluent.io/api/plugins" target="_blank" rel="noopener">https://api.hub.confluent.io/api/plugins</a>接口返回的配置信息包含的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://api.hub.confluent.io/api/plugins</span><br></pre></td></tr></table></figure>
<p>上面接口返回的信息其中一个如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"logo"</span>:<span class="string">"https://d1i4a15mxbxib1.cloudfront.net/api/plugins/debezium/debezium-connector-mysql/versions/0.9.2/assets/color_debezium_256px.png"</span></span><br></pre></td></tr></table></figure>
<h1><span id="处理过程">处理过程</span></h1><p>第一步通过站长工具，找到d1i4a15mxbxib1.cloudfront.net的IP地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">d1i4a15mxbxib1.cloudfront.net 52.84.225.219 877978075 新加坡 Amazon数据中心</span><br><span class="line">d1i4a15mxbxib1.cloudfront.net 52.84.225.183 877978039 新加坡 Amazon数据中心</span><br><span class="line">d1i4a15mxbxib1.cloudfront.net 52.84.225.134 877977990 新加坡 Amazon数据中心</span><br><span class="line">d1i4a15mxbxib1.cloudfront.net 52.84.225.114 877977970 新加坡 Amazon数据中心</span><br></pre></td></tr></table></figure>
<p>第二步在cp-docker-images/examples/cp-all-in-one/Dockerfile，找到confluentinc/ksql-examples镜像的Dockerfile文件</p>
<figure class="highlight bash"><figcaption><span>Dockerfile</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright 2018 Confluent Inc.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line">FROM confluentinc/cp-kafka-connect:5.1.2</span><br><span class="line"></span><br><span class="line">ENV CONNECT_PLUGIN_PATH=<span class="string">"/usr/share/java,/usr/share/confluent-hub-components"</span></span><br><span class="line"></span><br><span class="line">RUN confluent-hub install --no-prompt confluentinc/kafka-connect-datagen:latest</span><br></pre></td></tr></table></figure>
<p>第三步，单独构建镜像，指定host配置，使用其中一个即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker build -t confluentinc/ksql-examples:5.1.2 \</span><br><span class="line">&gt;--add-host d1i4a15mxbxib1.cloudfront.net:52.84.225.183 \</span><br><span class="line">&gt;-f Dockerfile .</span><br></pre></td></tr></table></figure>
<p>第四步，docker-compose启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d --build</span><br></pre></td></tr></table></figure>
<h1><span id="参考">参考</span></h1><p><a href="https://blog.csdn.net/zcw1994/article/details/84568426" target="_blank" rel="noopener">docker容器添加自定义hosts</a><br><a href="https://docs.docker.com/network/proxy/#configure-the-docker-client" target="_blank" rel="noopener">Configure Docker to use a proxy server</a><br><a href="https://github.com/confluentinc/cp-docker-images/issues/654" target="_blank" rel="noopener">Unable to install kafka-connect-datagen:0.1.0 #654</a><br><a href="https://docs.confluent.io/current/quickstart/ce-docker-quickstart.html" target="_blank" rel="noopener">Confluent Platform Quick Start (Docker)</a></p>
]]></content>
      <categories>
        <category>Apache Kafka</category>
      </categories>
      <tags>
        <tag>Apache Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>JAAS Authentication Example</title>
    <url>/posts/1376089128.html</url>
    <content><![CDATA[<p>例子程序来源于Java文档。</p>
<ol>
<li>配置Kerberos的Server端，配置KDC（kdc.conf）和Server（krb5.conf）。</li>
<li>增加一个Principal，一个用于程序测试。</li>
<li>将JassAcn.java和Jaas.conf文件拷贝到一个文件夹。</li>
<li>Javac编译JassAcn.java文件</li>
<li>用下面的命令执行class文件，替换成自己的配置<a id="more"></a>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Djava.security.krb5.realm=HIGHGO.COM-Djava.security.krb5.kdc=hadooph.highgo.com-Djava.security.auth.login.config=jaas.conf JaasAcn</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>运行此class文件，提示输入Kerberosusername和Kerberos password，验证成功，打印Authentication succeeded!，验证失败，打印Authenticationfailed和失败原因。</li>
<li>也可将程序导入到Eclipse里运行，只要在运行时，在虚拟机参数里加入<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djava.security.krb5.realm=HIGHGO.COM</span><br><span class="line">-Djava.security.krb5.kdc=hadooph.highgo.com</span><br><span class="line">-Djava.security.auth.login.config=jaas.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>即可。调试什么的更方便。</p>
<p>Appendix</p>
<figure class="highlight java"><figcaption><span>JaasAcn.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.security.auth.login.LoginContext;</span><br><span class="line"><span class="keyword">import</span> javax.security.auth.login.LoginException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.security.auth.callback.TextCallbackHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This JaasAcn application attempts to authenticate a user and reports whether</span></span><br><span class="line"><span class="comment"> * ornot the authentication was successful.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JaasAcn</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Obtain a LoginContext,needed for authentication. Tell it</span></span><br><span class="line">		<span class="comment">// to use the LoginModuleimplementation specified by the</span></span><br><span class="line">		<span class="comment">// entry named"JaasSample" in the JAAS login configuration</span></span><br><span class="line">		<span class="comment">// file and to also use thespecified CallbackHandler.</span></span><br><span class="line">		LoginContext lc = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lc = newLoginContext(<span class="string">"JaasSample"</span>, <span class="keyword">new</span> TextCallbackHandler());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (LoginException le) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot create LoginContext. "</span> + le.getMessage());</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SecurityException se) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot create LoginContext. "</span> + se.getMessage());</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// attemptauthentication</span></span><br><span class="line">			lc.login();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (LoginException le) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Authentication failed:"</span>);</span><br><span class="line">			System.err.println(<span class="string">"  "</span> + le.getMessage());</span><br><span class="line">			System.exit(-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Authentication succeeded!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>Jaas.conf</span></figcaption><table><tr><td class="code"><pre><span class="line">JaasSample &#123;</span><br><span class="line"> com.sun.security.auth.<span class="keyword">module</span>.Krb5LoginModule required;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java ABC</tag>
      </tags>
  </entry>
  <entry>
    <title>Jaas Guide</title>
    <url>/posts/706353777.html</url>
    <content><![CDATA[<p>本指南扩展了在JAAS Authentication文档中的程序和policy文件，展示了JAAS Authorization组件，这个组件确保被认证的调用者对后续的安全敏感的操作有访问控制的权利（权限）。因为授权组件首先需要用户认证操作完成，请先阅读JAAS Authentication的doc。<br><a id="more"></a><br>本教程剩下的部分包含目录列出的内容：</p>
<p>如果你想先看下教程代码的运行，你可以直接跳到运行代码的部分，然后再回来看其他的部分了解更多。</p>
<h1><span id="什么是jaas-authorization">什么是JAAS Authorization？</span></h1><p>JAAS授权扩展了已经存在的JAVA安全机构，已存在的安全架构用一个策略文件来指定执行的代码被授予什么访问权限。在Java 2平台中介绍的这个架构是以代码为中心的。也就是说，权限基于代码的特性被授予：代码从哪里来，是否有数字签名，如果有，是谁签的。我们在JAAS Authentication教程的jassacn.policy文件中看到的例子。这个文件包含下面的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase<span class="string">"file:./JaasAcn.jar"</span> &#123;</span><br><span class="line">  permission javax.security.auth.AuthPermission</span><br><span class="line">                   <span class="string">"createLoginContext.JaasSample"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>授权JaasAcn.jar中的代码指定的权限（没有指定签名者，所有代码签不签名不重要）。</p>
<p>JAAS授权增加新的用户中心的访问权限到已存在的代码中心的访问权限。权限的授予标准不仅基于什么代码在运行而且考虑到谁在运行它。</p>
<p>当一个应用用JAAS认证来认证一个用户（或者其他的实体，比如一个服务），一个Subject被创建作为结果。Subject的作用是代替被认证的用户。一个Subject由很多Principal组成，每一个Principal代表那个用户的一个身份。例如。一个Subject可以有一个名字身份（“Susan Smith“）和一个社会安全号码（”987-65-4321“），因此，可以区分于其他的Subject。</p>
<p>权限可以被策略文件来授予给特定的Principal。在用户被认证后，应用可以将一个Subject和当前的访问控制环境联系。对于后续的安全检查操作，（例如，一个本地的文件访问），java运行时环境将自动判定策略是否授权给一个特定的Principal需要的权限，如果授权了，操作将被允许，只有在与Subject连接的访问控制上下文中包含指定的Principal。</p>
<h1><span id="jaas授权如何工作">JAAS授权如何工作？</span></h1><p>一个授权操作，需要下面的步骤：</p>
<ol>
<li>用户必须被认证，就像在JAAS Authentication tutorial里描述的</li>
<li>安全策略必须配置基于Principal的条目</li>
<li>认证的结果，Subject必须与当前的访问控制环境连接。</li>
</ol>
<h1><span id="基于principal的策略文件怎么写">基于Principal的策略文件怎么写？</span></h1><p>策略文件的grant语句可以选择性的包含一个或者多个Principal字段。Principal字段声明用户或者被特定Principal代表的其他实体，执行特定的代码，有指定的权限。</p>
<p>因此，grant语句基本的格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant &lt;signer(s) field&gt;, &lt;codeBase URL&gt; &lt;<span class="function">Principal <span class="title">field</span><span class="params">(s)</span>&gt; </span>&#123; </span><br><span class="line">  permission perm_class_name <span class="string">"target_name"</span>, <span class="string">"action"</span>; </span><br><span class="line">  .... </span><br><span class="line">  permission perm_class_name <span class="string">"target_name"</span>, <span class="string">"action"</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个签名。CodeBase和Principal字段所在的位置是可选的，字段间的顺序也不重要：<br>一个Principal字段可以像下面这样：<br>也就是说，单词Principal（位置不重要），紧跟着一个Principal类和一个Principal的名字。<br>一个Principal类是一个实现了java.security.Principal接口的类。所有的Principal对象有一个相关联的名字，这个名字可以调用它的getName方法得到。名字所用的格式依赖于每一个Principal的实现。</p>
<p>本教程中使用的Kerberos的认证机制创建的Subject中的Principal的类型是javax.security.auth.kerberos.KerberosPrincipal，也就是应该被用作grant语句的Principal_class的部分。KerberosPrincipals 的用户名是” name@realm “格式。所以，如果用户名是mjones，Realm是KRBNT-OPS.ABC.COM，那么grant语句中使用的principal_name就是<a href="mailto:mjones@KRBNT-OPS.ABC.COM" target="_blank" rel="noopener">mjones@KRBNT-OPS.ABC.COM</a>。</p>
<p>在一个grant语句中可能包含多个Principal字段。如果多个Principal字段被指定，grant语句中的权限仅在Subject包含所有这些Principal时被授予。<br>为了给不同的Principal授予同样的权限，创建多个只包含一个Principal字段的grant语句。</p>
<p>本教程的策略文件包含一个只有一个Principal字段的grant语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase <span class="string">"file:./SampleAction.jar"</span>,</span><br><span class="line">    Principal javax.security.auth.kerberos.KerberosPrincipal </span><br><span class="line">        <span class="string">"your_user_name@your_realm"</span>  &#123;</span><br><span class="line"> </span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"java.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"user.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.io.FilePermission <span class="string">"foo.txt"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将Kerberos的用户名和Realm替换成你自己的。<br>上边的配置指出，显式授予指定的Principal执行SampleAction.jar中的代码的权限。</p>
<h1><span id="如何将一个subject和访问控制上下文关联">如何将一个Subject和访问控制上下文关联?</span></h1><p>为了创建和用访问控制上下文关联一个Subject，你需要下面的过程：</p>
<ol>
<li>用户必须先被认证，就是JAAS Authentication joc中描述的。</li>
<li>Subject类的静态的doAs方法必须被调用，传给其一个认证了的Subject和一个java.security.PrivilegedAction或者java.security.PrivilegedExceptionAction。（(See API for PrivilegedBlocks fora comparison of PrivilegedAction and PrivilegedExceptionAction.)）。doAs方法用当前的访问控制上下文关联给定的Subject，然后调用Action的run方法。Run方法的实现包含作为指定的Subject，所有被执行的代码。这样Action以特定的Subject执行。</li>
</ol>
<p>Subject类的静态的doAsPrivileged 方法可以代替doAs方法被调用。除了传给doAs方法的参数外，doAsPrivileged 需要第三个参数：一个AccessControlContext对象。不想doAs方法，用当前的访问控制上下文联系Subject，方法doAsPrivileged 用给定的访问控制上下文联系Subject。See doAs vs. doAsPrivileged in theJAAS Reference Guide for a comparison of those methods。</p>
<h1><span id="授权教程代码">授权教程代码</span></h1><p>本教程的代码包含两个文件：</p>
<ol>
<li>JaasAzn.java除了Subject.doAsPrivileged调用中额外的代码，与JAASAuthentication教程中的JaasAcn.java文件一样。</li>
<li>SampleAction.java包含SampleAction类。这个类实现了PrivilegedAction，有一个run方法，这个方法包含了所有我们想基于Principal认证检查执行的代码。</li>
</ol>
<h2><span id="jaasaznjava">JaasAzn.java</span></h2><p>JaasAzn.java与之前的教程中用的到JaasAcn.java完全一样，除了在mian方法的在认证完成后语句之后增加了3条语句。这些语句使一个带表一个通过认证的用户的Subject与当前访问控制上下文关联，然后执行SampleAction的run方法中的一些代码。用访问控制表关联Subject使SampleAction的run方法中安全敏感的操作（任何run方法中直接或间接调用的代码）在代表一个认证的用户的Principal被在当前的策略中被授予必要的权限时被执行。</p>
<p>跟JaasAcn.java一样，JaasAzn.java初始化一个LoginContext lc和调用它的login方法来执行认证。如果成功，被认证的Subject（包含一个代表这个用户的Principal）通过LoginContext的getSubject方法获得。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject mySubject = lc.getSubject();</span><br></pre></td></tr></table></figure>
<p>然后，Main方法调用Subject.doAsPrivileged，将通过认证的Subjectmysubject传给它，一个PrivilegedAction(SampleAction)和一个null AccessControlContext，就像下边的描述：<br>SampleAction 通过下面的方式被初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrivilegedAction action = <span class="keyword">new</span> SampleAction();</span><br></pre></td></tr></table></figure>
<p>Subject.doAsPrivileged 通过下面的方式被执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Subject.doAsPrivileged(mySubject, action, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>doAsPrivileged 方法调用PrivilegedAction action (SampleAction)  的run方法开始执行剩下的代码，这些代码被认为是代表mySubject执行。</p>
<p>传给doAsPrivileged 方法一个null作为第三个参数AccessControlContext 表明mySubject应用与一个新的空的AccessControlContext关联。这个结果是以mySubject运行时，发生在SampleAction执行期间的安全检查将只需要SampleAction自己的代码（或者其他它调用的代码）权限。注意，doAsPrivileged 的调用者在执行期间不需要任何的权限。</p>
<h2><span id="sampleactionjava">SampleAction.java</span></h2><p>SampleAction.java包含SampleAction类。这个类实现了java.security.PrivilegedAction，有一个包含所有mySubject想执行的所有代码。对于本教程，我们将做3个步骤，每一个步骤都只有在代码被授予必要的权限的情况下才能做。我们将：</p>
<ol>
<li>读和打印java.home系统属性值</li>
<li>读和打印user.name的系统属性值</li>
<li>判断foo.txt文件在当前目录是否存在</li>
</ol>
<p>这是代码：</p>
<figure class="highlight java"><figcaption><span>SampleAction</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleAction</span> <span class="keyword">implements</span> <span class="title">PrivilegedAction</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"\nYour java.home property value is: "</span></span><br><span class="line">                + System.getProperty(<span class="string">"java.home"</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">"\nYour user.home property value is: "</span></span><br><span class="line">                + System.getProperty(<span class="string">"user.home"</span>));</span><br><span class="line"> </span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">"foo.txt"</span>);</span><br><span class="line">    System.out.print(<span class="string">"\nfoo.txt does "</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f.exists())</span><br><span class="line">        System.out.print(<span class="string">"not "</span>);</span><br><span class="line">    System.out.println(<span class="string">"exist in the current working directory."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="登录配置文件">登录配置文件</span></h1><p>本教程使用的登录配置文件与在JAAS Authentication教程中使用的完全一样。因此，我们可以用jaas.conf文件，文件仅包含一个条目：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JaasSample &#123;</span><br><span class="line">  com.sun.security.auth.<span class="keyword">module</span>.Krb5LoginModule required;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个条目被命名为“JaasSample”，也就是我们的教程的应用程序JaasAcn和JaasAzn应用的名字。这个条目指定了用来做认证的LoginModule 是com.sun.security.auth.module包中的Krb5LoginModule ，为了使认证被认为是成功的，Krb5LoginModule需 要“succeed”。 Krb5LoginModule只有在用户提供的用户名和密码成功的登录到Kerberos KDC时才成功。</p>
<h1><span id="策略文件">策略文件</span></h1><p>授权教程保罗两个类，JaasAzn和SampleAction。每个类中的代码包含一些安全敏感的操作，因此，相关的权限需要在一个策略文件中被执行，以使操作被允许执行。</p>
<p>JaasAzn需要的权限<br>JaasAzn类的main方法做了两个操作需要权限的操作：</p>
<ol>
<li>创建了一个LoginContext</li>
<li>调用Subject类的doAsPrivileged 静态方法</li>
</ol>
<p>LoginContext的创建与认证教程中的方式一样，因此，它需要与createLoginContext.JaasSample相同的权限javax.security.auth.AuthPermission。</p>
<p>为了调用Subject类的doAsPrivileged 方法，你需要对doAsPrivileged有一个javax.security.auth.AuthPermission对象。</p>
<p>假设JaasAzn类被放到jaasAzn.jar文件中，这些权限需要通过策略文件中配置grant语句来授权：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase <span class="string">"file:./JaasAzn.jar"</span> &#123;</span><br><span class="line">   permission javax.security.auth.AuthPermission </span><br><span class="line">                    <span class="string">"createLoginContext.JaasSample"</span>;</span><br><span class="line">   permission javax.security.auth.AuthPermission <span class="string">"doAsPrivileged"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SampleAction需要的权限<br>SampleAction代码做了3个需要权限的操作：</p>
<ol>
<li>读取java.home系统属性</li>
<li>读取user.home系统属性</li>
<li>检查当前文件中是否有foo.txt的文件</li>
</ol>
<p>这些操作需要的权限如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">permission java.util.PropertyPermission <span class="string">"java.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">permission java.util.PropertyPermission <span class="string">"user.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">permission java.io.FilePermission <span class="string">"foo.txt"</span>, <span class="string">"read"</span>;</span><br></pre></td></tr></table></figure>
<p>我们需要给中的SampleAction.class代码授予权限，我们将吧SampleAction.class放到SampleAction.jar文件中。然而，对于这个特定的grant语句，我们希望不仅授权给代码，而且授权给执行代码的特定的用户，来指定如何限制一个特定用户的访问权限。</p>
<p>因此，就像在中 How Do You Make Principal-BasedPolicy File Statements?,描述的，我们的grant语句看起来像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grant codebase <span class="string">"file:./SampleAction.jar"</span>,</span><br><span class="line">    Principal javax.security.auth.kerberos.KerberosPrincipal </span><br><span class="line">        <span class="string">"your_user_name@your_realm"</span>  &#123;</span><br><span class="line"> </span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"java.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"user.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.io.FilePermission <span class="string">"foo.txt"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用你的Kerberos用户名和Realm代替。例如，如果你的用户名是“mjones”，Realm是“KRBNT-OPERATIONS.ABC.COM”。你将用<a href="mailto:mjones@KRBNT-OPERATIONS.ABC.COM" target="_blank" rel="noopener">mjones@KRBNT-OPERATIONS.ABC.COM</a>。</p>
<p>策略文件的全部内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Java 2 Access Control Policy for the JaasAzn Application **/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/** Code-Based Access Control Policy for JaasAzn **/</span></span><br><span class="line"> </span><br><span class="line">grant codebase <span class="string">"file:./JaasAzn.jar"</span> &#123;</span><br><span class="line"> </span><br><span class="line">   permission javax.security.auth.AuthPermission </span><br><span class="line">                    <span class="string">"createLoginContext.JaasSample"</span>;</span><br><span class="line">   permission javax.security.auth.AuthPermission <span class="string">"doAsPrivileged"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/** User-Based Access Control Policy for the SampleAction class</span></span><br><span class="line"><span class="comment"> ** instantiated by JaasAzn </span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line">grant    codebase <span class="string">"file:./SampleAction.jar"</span>,</span><br><span class="line">    Principal javax.security.auth.kerberos.KerberosPrincipal </span><br><span class="line">        <span class="string">"your_user_name@your_realm"</span>  &#123;</span><br><span class="line"> </span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"java.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.util.PropertyPermission <span class="string">"user.home"</span>, <span class="string">"read"</span>;</span><br><span class="line">   permission java.io.FilePermission <span class="string">"foo.txt"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">``` java</span><br><span class="line"># 运行授权教程的代码</span><br><span class="line">为了执行我们的JAAS授权教程代码，所有你需要做的是：</span><br><span class="line"></span><br><span class="line">## 将下面的文件到一个文件夹</span><br><span class="line"></span><br><span class="line">The JaasAzn.java sourcefile.</span><br><span class="line">The SampleAction.java sourcefile.</span><br><span class="line">The jaas.conf loginconfiguration file.</span><br><span class="line">The jaasazn.policy policyfile.</span><br><span class="line"></span><br><span class="line"># Replace "your_user_name@your_realm"in jaasazn.policy with youruser name and realm.</span><br><span class="line"># Compile SampleAction.java and JaasAzn.java:</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">javac SampleAction.java JaasAzn.java</span><br></pre></td></tr></table></figure>
<h1><span id="create-a-jar-file-named-jaasaznjar-containing-jaasaznclass">Create a JAR file named JaasAzn.jar containing JaasAzn.class:</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -cvf JaasAzn.jar JaasAzn<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<h1><span id="create-a-jar-file-named-sampleactionjar-containing-sampleactionclass">Create a JAR file named SampleAction.jar containing SampleAction.class:</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar -cvf SampleAction.jar SampleAction<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<h1><span id="execute-the-jaasazn-applicationspecifying">Execute the JaasAzn application,specifying</span></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. by anappropriate -classpath clause that classes should be searched <span class="keyword">for</span> intheJaasAzn.jar and SampleAction.jar JAR files,</span><br><span class="line"><span class="number">2</span>. by -Djava.security.manager thata security manager should be installed,</span><br><span class="line"><span class="number">3</span>. by -Djava.security.krb5.realm=&lt;your_realm&gt; thatyour Kerberos realm is the one specified.</span><br><span class="line"><span class="number">4</span>. by -Djava.security.krb5.kdc=&lt;your_kdc&gt; thatyour Kerberos KDC is the one specified.</span><br><span class="line"><span class="number">5</span>. by -Djava.security.policy=jaasazn.policy thatthe policy file to be used isjaasazn.policy, and</span><br><span class="line"><span class="number">6</span>. by -Djava.security.auth.login.config=jaas.conf thatthe login configuration file to be used is jaas.conf.</span><br></pre></td></tr></table></figure>
<p>下面是Windows下全部的命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -classpath JaasAzn.jar;SampleAction.jar </span><br><span class="line"> -Djava.security.manager </span><br><span class="line"> -Djava.security.krb5.realm=&lt;your_realm&gt; </span><br><span class="line"> -Djava.security.krb5.kdc=&lt;your_kdc&gt; </span><br><span class="line"> -Djava.security.policy=jaasazn.policy </span><br><span class="line"> -Djava.security.auth.login.config=jaas.conf JaasAzn</span><br></pre></td></tr></table></figure>
<p>这是UNIX下全部的命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -classpath JaasAzn.jar:SampleAction.jar </span><br><span class="line"> -Djava.security.manager </span><br><span class="line"> -Djava.security.krb5.realm=&lt;your_realm&gt; </span><br><span class="line"> -Djava.security.krb5.kdc=&lt;your_kdc&gt; </span><br><span class="line"> -Djava.security.policy=jaasazn.policy </span><br><span class="line"> -Djava.security.auth.login.config=jaas.conf JaasAzn</span><br></pre></td></tr></table></figure>
<p>将这些命令放到一行里。<br>你将被提示输入Kerberos的用户名和密码，指定在登录配置文件中的底层的Kerberos认证机制将登录到Kerberos。如果你的登录成功，你讲看到Authenticationsucceeded!信息，如果不是，你将看到AuthenticationFailed。<br>一旦认证成功，程序剩下的部分（SampleAction）将代表你这个用户执行，需要你已经被授权合适的权限。Jassazn.policy策略文件将授权给你必要的权限，所以你将看到java.home and user.home和你的当前文件夹是否有一个名叫foo.txt的文件的值被显示。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java ABC</tag>
        <tag>JAAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Instument Package</title>
    <url>/posts/1167341847.html</url>
    <content><![CDATA[<h1><span id="javalanginstrument简介">java.lang.instrument简介</span></h1><p>Java5之后，增加了一个包java.lang.instrument，这个包的东西很少，两个接口，ClassFileTransformer和Instrumentation，一个类ClassDefinition，还有两个Exception：IllegalClassFormatException和UnmodifiableClassException；<br>先剧透一下整个包最重要的接口Instrumentation提供的两个功能，总体的功能就是Instrument了，具体来讲两个，从字节码级别为类增加Instrument所需的代码，第二个是获取对象的大小。<br>先看一下这个包的描述吧，下面是JavaDoc的翻译：<br><a id="more"></a></p>
<h2><span id="package-javalanginstrument">package java.lang.instrument</span></h2><p>这个包提供允许一个Java程序语言的代理测量运行在JVM中的程序的多个指标的服务。</p>
<h2><span id="package-javalanginstrumentdescription">Package Java.lang.instrumentDescription</span></h2><p>这个包提供允许一个Java程序语言的代理测量运行在JVM中的程序的多个指标的服务。监测的机制是修改类的方法的字节码。</p>
<h2><span id="package-specification">Package Specification</span></h2><p>一个代理就是部署一个Jar文件。Jar文件的manifest文件（每个jar包根目录下有个META-INF文件夹，此文件夹下的MANIFEST.MF文件就是这里的manifest文件）需要指定这个代理的类，指定之后，这个类将被加载以启动代理。因为支持命令行接口，所以一个代理可以通过在命令行中指定一个选项来移动。具体的实现也可能支持在虚拟机启动之后的某个时间开启代理。例如，一个具体的实现可能提供一个机制，使一个工具附加到一个运行的应用中，然后，初始化这个工具的代理，加载到正在运行的应用中。关于类的加载如何被初始化的细节，依赖于具体的实现。</p>
<h2><span id="command-line-interface">Command-Line Interface</span></h2><p>在用命令行接口的实现中，一个代理可以通过增加下面的Option到命令行中启动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-javaagent:jarpath[=options]</span><br></pre></td></tr></table></figure>
<p>Jarpath是代理jar文件的路径。Option是代理的选项。上边的命令可以在同一个命令行中使用多次，因此，可以创建多个代理。多个代理可以使用同一jarpath。一个代理Jar文件必须符合Jar文件规范。</p>
<p>一个代理jar文件的manifest必须包含Premain-Class属性。这个属性的值是代理类的名字。代理类必须实现一个public static的premain 方法，与应用程序中的main方法作为程序入口的原理类似。JVM初始化之后，每一个premain方法将被以代理被指定时的顺序调用，然后应用程序真正的main方法将被调用。每一个premain方法必须以启动的顺序返回结果。（premain=pre-main）</p>
<p>Premain方法有两个重载的方法。JVM首先尝试调用代理类中下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">voidpremain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果代理类没有实现这个方法，jvm将尝试调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">voidpremain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>代理类可能还有一个agentmain方法，当代理类在JVM启动之后被启动时使用。当代理类使用命令行选项被启动时，agentmain方法不被调用。</p>
<p>Agent类通过系统的类加载器加载（ClassLoader.getSystemClassLoader）。这个类加载器通常跟用来加载包含应用程序的main方法的类加载器是一个。Premain方法将运行在跟应用程序main方法同样的安全机制和类加载下。代理的premain方法做什么是没有限制的。任何应用程序main方法可以做的，包括创建线程，在premain中都是合法的。</p>
<p>每一个代理经由agentArgs参数传给它的代理选项。代理选项以一个字符串被被传递，任何附加的解析操作应该是代理自己执行。</p>
<p>如果代理不能被解析（例如，因为代理类不能加载，或者因为代理类没有一个合适的premain方法），JVM将会abort。如果一个premain方法跑出一个未捕获的错误，JVM将会abort。</p>
<h2><span id="starting-agents-after-vm-startup">Starting Agents After VM Startup</span></h2><p>一个代理具体的实现可能提供一个在JVM启动之后启动的机制。关于代理被初始化的细节是具体实现特定的，但是通常应用程序已经启动，应用程序的main方法已经被调用。在代理的实现支持在JVM启动之后启动的情况下，需要遵循下面的规则：</p>
<ol>
<li>代理的Jar文件中的manifest文件必须包含Agent-Class属性。这个属性的值是代理类的名字。</li>
<li>代理类必须实现一个public static agentmain方法</li>
<li>系统类加载器（ ClassLoader.getSystemClassLoader）必须支持增加一个代理Jar文件到系统类路径。</li>
</ol>
<p>代理的Jar文件被追加到系统类路径中。这个类加载器是通常用来加载包含应用程序main方法的类的类加载器。代理类被加载之后，JVM尝试调用agentmain方法。JVM首先尝试调用代理类中的下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果代理类中没有实现这个方法，然后JVM尝试调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">voidagentmain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个代理类可能也有一个premain方法，当代理在命令行选项中启动时使用；当这个代理类在JVM启动之后启动时，premain方法不会被调用。</p>
<p>代理通过agentArgs参数传给代理选项。代理选项以字符串的形式传给代理内部的方法，任何附加的解析操作应该代理自己操作。</p>
<p>Agentmain方法应该做一些启动代理之前必要的初始化操作。当启动完成时，这个方法应该返回。如果代理不能被启动（例如，因为代理类不能被加载，或者因为代理类不包含一致的agentmain方法），JVM将不会被abort。如果agentmain方法抛出一个未捕获的错误，这个错误将被忽略。</p>
<p>注：著名的Java运行时分析工具Profiler有在监测Java程序时有两种模式，一种是用Profiler启动应用，一种是应用启动，然后附加到Profiler中，就是分别用的上边的两种方式。</p>
<h2><span id="manifest-attributes">Manifest Attributes</span></h2><p>下面的manifest属性在一个代理的jar文件中被定义：</p>
<p>Premain-Class</p>
<p>当一个代理在JVM启动时被指定时，这个属性指定代理使用的类。也就是，这个类包含premain方法。当一个代理在JVM启动时被指定时，这个属性是必须的。如果没有配置这个属性，JVM将会abort。注意：这是一个雷的名字，不是一个文件名活路径。</p>
<p><strong>Agent-Class</strong><br>如果一个代理的实现支持在JVM启动之后的某个时间启动，这个属性指定一个代理类。也就是说，这个类要包含agentmain方法。这个属性是必须的，如果不配置的话，代理将不会被启动。注意：这是一个类的名字，不是一个文件名字，也不是文件路径。</p>
<p><strong>Boot-Class-Path</strong><br>这个代理的实现中用到的第三方jar包都放到这里边。</p>
<p><strong>Can-Redefine-Classes</strong><br>Boolean（true或false）。Agent是否可以重定义类。可选的，默认是false。</p>
<p><strong>Can-Retransform-Classes</strong><br>Boolean（true或false）。Agent是否可以将类变回原形。可选的，默认是false。</p>
<p><strong>Can-Set-Native-Method-Prefix</strong><br>Boolean（true或false）。Agent是否可以设置本地方法的前缀。可选的，默认是false。</p>
<p>一个代理Jar文件中的manifest文件可能同时包含Premain-Class和Agent-Class属性。当代理在命令行中用-javaagent选项被启动，使用Premain-Class属性指定的代理类的名字，然后Agent-Class属性的配置被忽略。相似地，如果代理在JVM启动之后的某个时间启动，使用Agent-Class属性指定的类的名字，Premain-Class属性被忽略。</p>
<h1><span id="instrumentation">Instrumentation</span></h1><p>下面再看一下Instrumentation这个最主要的接口的一些介绍。</p>
<p>这是一个接口，提供了监测java程序语言代码的服务。Instrumentation将附加的功能的字节码添加到被监控的方法中，来收集应用的运行的一些数据。因为这个改变只有增加东西，监测工具可以不用修改应用的状态和表现。这样的工具包括监控代理，分析工具，代码覆盖分析器和事件日志器等。</p>
<p>有两种方式获得一个Instrumentation接口的实例：</p>
<ol>
<li>当JVM启动时，指定一个代理类。在这种情况下，一个Instrumentation实例传到代理类的premain方法中。</li>
<li>JVM提供可以让代理类在JVM启动后启动的机制。在这种情况下，一个Instrumentation实例传给代理的agentmain方法。</li>
</ol>
<p>这两种机制在上边的package specification中有详尽的描述。</p>
<p>一旦一个代理获取到一个Instrumentation实例，代理可以再之后的任何时刻调用实例的方法。</p>
<h2><span id="method-summary">Method Summary</span></h2><p>主要的方法就是下面几个：</p>
<p>addTransformer：指定一个ClassFileTransformer对象。可以先看下下面ClassFileTransformer接口的介绍。<br>getAllLoadedClasses：返回当前JVM中加载的所有的类的数组（牛逼）<br>getInitiatedClasses：返回指定的类加载器中的所有的类的数据（牛逼，too）<br>getObjectSize：返回一个对象近似的大小<br>redefineClasses：用给定的类的字节码数组替换指定的类的字节码文件，也就是重新定义指定的类<br>retransformClasses：指定一系列的Class对象，被指定的类都会重新变回去（去掉附加的字节码）<br>剩下的几个都是对上边manifest文件中配置的属性的一下操作和运行时接口。</p>
<p>到这，看下Instrumentation接口的主要功能，从Instrumentation接口提供的这几个方法，可以看出Instrumentation的主要功能，就是修改类的字节码文件，更确切的说是修改类的字节码文件，增加自定义的功能的字节码，生成一个新的字节码文件。这是这个接口存在的最主要的意义。</p>
<h1><span id="classfiletransformer">ClassFileTransformer</span></h1><p>先看下Doc上的简介，一个代理提供一个为了改变类文件而存在的接口的实现。这个改变发生在这个类被JVM定义之前。</p>
<p>这个接口只有一个方法transform，将类的字节码传给这个方法，然后返回一个增加了自定义的功能的字节码的字节数组。</p>
<p>这个接口存在的意义，主要是解耦Instrumentation类和改变类文件的操作。</p>
<h1><span id="classdefinition">ClassDefinition</span></h1><p>这个类只在Instrumentation#redefineClasses方法中被调用，这个类有两个域，</p>
<p>Class mClass；</p>
<p>Byte[] mClassFile；</p>
<p>mClass是要重新定义的类的Class对象</p>
<p>mClassFile是新的类的字节码数组</p>
<h1><span id="example1">example1</span></h1><p>下面举一个简单的例子，来感受一下，来自网络，功能是打印每一个方法的执行时间。</p>
<h2><span id="agent类">Agent类</span></h2><figure class="highlight java"><figcaption><span>PerfMonAgent</span></figcaption><table><tr><td class="code"><pre><span class="line">packagecom.highgo.test.instrumentation;</span><br><span class="line"> </span><br><span class="line">importjava.lang.instrument.ClassFileTransformer;</span><br><span class="line">importjava.lang.instrument.Instrumentation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerfMonAgent</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation inst = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation_inst)</span> </span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"PerfMonAgent.premain()was called. I am premain!"</span>);</span><br><span class="line">                   <span class="comment">// Initialize the static variables we use to trackinformation.</span></span><br><span class="line">                   inst = _inst;</span><br><span class="line">                   <span class="comment">// Set up the class-file transformer.</span></span><br><span class="line">                   ClassFileTransformer trans = <span class="keyword">new</span> PerfMonXformer();</span><br><span class="line">                   System.out.println(<span class="string">"Adding a PerfMonXformerinstance to the JVM."</span>);</span><br><span class="line">                   inst.addTransformer(trans);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs,Instrumentation _inst)</span> </span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"PerfMonAgent.premain()was called. I am agentmain!"</span>);</span><br><span class="line">                   <span class="comment">// Initialize the static variables we use to trackinformation.</span></span><br><span class="line">                   inst = _inst;</span><br><span class="line">                   <span class="comment">// Set up the class-file transformer.</span></span><br><span class="line">                   ClassFileTransformer trans = <span class="keyword">new</span> PerfMonXformer();</span><br><span class="line">                   System.out.println(<span class="string">"Adding a PerfMonXformerinstance to the JVM."</span>);</span><br><span class="line">                   inst.addTransformer(trans);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="classfiletransformer类">ClassFileTransformer类</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">packagecom.highgo.test.instrumentation;</span><br><span class="line"> </span><br><span class="line">importjava.lang.instrument.ClassFileTransformer;</span><br><span class="line">importjava.lang.instrument.IllegalClassFormatException;</span><br><span class="line">importjava.security.ProtectionDomain;</span><br><span class="line"> </span><br><span class="line">importjavassist.CannotCompileException;</span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtBehavior;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line">importjavassist.NotFoundException;</span><br><span class="line">importjavassist.expr.ExprEditor;</span><br><span class="line">importjavassist.expr.MethodCall;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerfMonXformerimplements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, StringclassName, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">                            ProtectionDomain protectionDomain, <span class="keyword">byte</span>[]classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">                   <span class="keyword">byte</span>[] transformed = <span class="keyword">null</span>;</span><br><span class="line">                   System.out.println(<span class="string">"Transforming "</span> +className);</span><br><span class="line">                   ClassPool pool = ClassPool.getDefault();</span><br><span class="line">                   CtClass cl = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                            cl = pool.makeClass(newjava.io.ByteArrayInputStream(classfileBuffer));</span><br><span class="line">                            <span class="keyword">if</span> (cl.isInterface() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                                     CtBehavior[] methods =cl.getDeclaredBehaviors();</span><br><span class="line">                                     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                               <span class="keyword">if</span>(methods[i].isEmpty() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                                                        doMethod(methods[i]);</span><br><span class="line">                                               &#125;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                     transformed = cl.toBytecode();</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            System.err.println(<span class="string">"Could notinstrument  "</span> + className + <span class="string">",  exception : "</span> + e.getMessage());</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                     cl.detach();</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> transformed;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doMethod</span><span class="params">(CtBehavior method)</span> throwsNotFoundException, CannotCompileException </span>&#123;</span><br><span class="line">                   <span class="comment">// method.insertBefore("long stime =System.nanoTime();");</span></span><br><span class="line">                   <span class="comment">//method.insertAfter("System.out.println(\"leave"+method.getName()+" andtime:\"+(System.nanoTime()-stime));");</span></span><br><span class="line">                   method.instrument(<span class="keyword">new</span> ExprEditor() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">edit</span><span class="params">(MethodCall m)</span> throwsCannotCompileException </span>&#123;</span><br><span class="line">                                     m.replace(<span class="string">"&#123; long stime =System.nanoTime(); $_ = $proceed($$); System.out.println(\""</span></span><br><span class="line">                                                        +m.getClassName() + <span class="string">"."</span> + m.getMethodName() +<span class="string">":\"+(System.nanoTime()-stime));&#125;"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="manifestmf文件">MANIFEST.MF文件</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class:com.highgo.test.instrumentation.PerfMonAgent</span><br><span class="line">Boot-Class-Path: javassist.jar</span><br></pre></td></tr></table></figure>
<p>Boot-Class-Path这样写要将javassist.jar文件放到jar包的根目录</p>
<h2><span id="打jar包">打jar包</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar cvfm inst.jar MANIFEST.MFjavassist.jar com</span><br></pre></td></tr></table></figure>
<p>使用自己写的MANIFEST.MF文件，<br>将javassist.jar和com文件夹下的类打成jar包<br>这样这个jar包就作为一个提供打印方法时间的服务而存在了</p>
<h2><span id="使用instjar">使用inst.jar</span></h2><p>随便编写一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> App().test();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"HelloWorld!!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行此类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -javaagent:../inst.jarclasspath .;../inst.jar App</span><br></pre></td></tr></table></figure>
<p>可以看到，将运行这个类的过程中用到的所有的类的方法的方法名+时间都打印出来了。</p>
<h1><span id="example12">example12</span></h1><p>这里使用第二种方式，也就是先启动JVM，再启动agent类的方式，做一个例子。</p>
<p>在使用JProfiler的quick attch时，我们的使用方法是这样的：运行我们的应用程序，切换到这个界面，我们的应用就会出现在下面这个地方，ID是OS分配给这个进程的进程ID，后边是进程的名字，其实attch用到的只是进程ID号；选中这个进程，就到了分析界面了。</p>
<p>我们下面的例子也是按照这个顺序：</p>
<ol>
<li>编写Agent，打包成服务</li>
<li>编写一个应用程序，运行</li>
<li>编写一个工具，将Agent的jar包attach到Agent所在的JVM（具体实现是将应用程序的ID传递给工具）</li>
</ol>
<h2><span id="编写agent">编写Agent</span></h2><figure class="highlight java"><figcaption><span>classPerfMonAgent</span></figcaption><table><tr><td class="code"><pre><span class="line">packagecom.highgo.test.instrumentation;</span><br><span class="line"> </span><br><span class="line">importjava.lang.instrument.ClassFileTransformer;</span><br><span class="line">importjava.lang.instrument.Instrumentation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> classPerfMonAgent &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Instrumentation inst = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs,Instrumentation _inst)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"PerfMonAgent.premain()was called. I am premain!"</span>);</span><br><span class="line">      <span class="comment">// Initialize the static variables we useto track information.</span></span><br><span class="line">      inst = _inst;</span><br><span class="line">      <span class="comment">// Set up the class-file transformer.</span></span><br><span class="line">      ClassFileTransformer trans = newPerfMonXformer();</span><br><span class="line">      System.out.println(<span class="string">"Adding aPerfMonXformer instance to the JVM."</span>);</span><br><span class="line">      inst.addTransformer(trans);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(StringagentArgs, Instrumentation _inst)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"PerfMonAgent.premain()was called. I am agentmain!"</span>);</span><br><span class="line">      inst = _inst;</span><br><span class="line">      Class&lt;?&gt;[] classes =inst.getAllLoadedClasses();</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; cls : classes) &#123;</span><br><span class="line">         System.out.println(cls.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">"classeslength:"</span>+classes.length);</span><br><span class="line">      System.out.println(<span class="string">"PerfMonAgent.premain()end!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把第二种方式用到的agentmain方法直接加到第一种方式使用的类中了。</p>
<h2><span id="编写manifest文件">编写MANIFEST文件</span></h2><figure class="highlight java"><figcaption><span>MANIFEST</span></figcaption><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Premain-Class:com.highgo.test.instrumentation.PerfMonAgent</span><br><span class="line">Agent-Class:com.highgo.test.instrumentation.PerfMonAgent</span><br><span class="line">Boot-Class-Path: javassist.jar</span><br></pre></td></tr></table></figure>
<p>只是增加了Agent-Class的配置。</p>
<h2><span id="将此agent打成jar包">将此Agent打成Jar包</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar cvfm inst.jar MANIFEST.MFjavassist.jar com</span><br></pre></td></tr></table></figure>
<p>还是上边用到的命令</p>
<h2><span id="编写应用程序">编写应用程序</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetVM</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">         Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就一个线程，一直运行着。</p>
<h2><span id="查看上边进程的id">查看上边进程的ID</span></h2><p>用jps命令可以方便的查看进程的ID，名字是应用程序main方法所在的类的名字。可以很容易的分辨出来。</p>
<h2><span id="运行attach工具类">运行Attach工具类</span></h2><figure class="highlight java"><figcaption><span>AttachUtil</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachUtil</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> AttachNotSupportedException, IOException, AgentLoadException,AgentInitializationException </span>&#123;</span><br><span class="line">      String id = <span class="string">"520384"</span>;</span><br><span class="line">      VirtualMachine vm = VirtualMachine.attach(id);</span><br><span class="line">        vm.loadAgent(<span class="string">"inst.jar"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了JDK的tools.jar工具包，不了解这个Jar包的朋友可以再本博客搜一下关于这个jar包的详细介绍。Eclipse默认加的jar包没有这个，可以从jdk的安装目录里找到，加到项目的sspath里就行了；如果是用javac去编译的话，只要将这个类加入到系统的classpath里就可以了，这个工具类就也可以编译，也可以运行了。</p>
<p>将ID修改成jps查看到的那个ID号，这个工具类就可以创建一个ID号所在的进程的VirtualMachine对象，这个对象就代表那个JVM。VirtualMachine#loadAgent方法可以加载一个Agent。</p>
<p>当AttachUtil方法运行到vm.loadAgent(“inst.jar”);这行代码的时候，就可以看到Eclipse的控制台会打印出PerfMonAgent# agentmain方法执行的打印内容,应用程序所在的JVM中加载的所有的类的名字。</p>
<h1><span id="instrumentationgetobjectsize">Instrumentation#getObjectSize</span></h1><p>从上边Instrumentation的method summary可以看出，Instrumentation接口的另一个功能就是获取一个对象的大小。</p>
<p>这里我们直接分析一下classmexer的源码</p>
<h2><span id="manifest文件">MANIFEST文件</span></h2><p>Classmexer的Agent使用的是第一种方式，所以看他的MANIFEST.MF文件如下：</p>
<figure class="highlight java"><figcaption><span>MANIFEST</span></figcaption><table><tr><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span></span><br><span class="line">Created-By: <span class="number">1.6</span><span class="number">.0</span> (SunMicrosystems Inc.)</span><br><span class="line">Premain-Class:com.javamex.classmexer.Agent</span><br></pre></td></tr></table></figure>
<p>这个项目只有两个类，Agent和MemoryUtil</p>
<h2><span id="agent类">Agent类</span></h2><p>Agent的主要目的是获取一个Instrumentation的实例。内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">packagecom.javamex.classmexer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentationinstrumentation;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args,Instrumentation instr)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    instrumentation = instr;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Instrumentation instr = instrumentation;</span><br><span class="line">    <span class="keyword">if</span> (instr == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> newIllegalStateException(<span class="string">"Agent not initted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="memoryutil类">MemoryUtil类：</span></h2><figure class="highlight java"><figcaption><span>MemoryUtil</span></figcaption><table><tr><td class="code"><pre><span class="line">packagecom.javamex.classmexer;</span><br><span class="line"> </span><br><span class="line">importjava.lang.instrument.Instrumentation;</span><br><span class="line">importjava.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryUtil</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> VisibilityFilter</span><br><span class="line">  &#123;</span><br><span class="line">    ALL, PRIVATE_ONLY,  NON_PUBLIC,  NONE;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">memoryUsageOf</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    returnAgent.getInstrumentation().getObjectSize(obj);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">deepMemoryUsageOf</span><span class="params">(Objectobj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deepMemoryUsageOf(obj,VisibilityFilter.NON_PUBLIC);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">deepMemoryUsageOf</span><span class="params">(Objectobj, VisibilityFilter referenceFilter)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    returndeepMemoryUsageOf0(Agent.getInstrumentation(), <span class="keyword">new</span> HashSet(), obj,referenceFilter);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">longdeepMemoryUsageOfAll</span><span class="params">(Collection&lt;? extends Object&gt; objs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deepMemoryUsageOfAll(objs,VisibilityFilter.NON_PUBLIC);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">longdeepMemoryUsageOfAll</span><span class="params">(Collection&lt;? extends Object&gt; objs, VisibilityFilterreferenceFilter)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Instrumentation instr =Agent.getInstrumentation();</span><br><span class="line">    <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">   </span><br><span class="line">    Set&lt;Integer&gt; counted = newHashSet(objs.size() * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object o : objs) &#123;</span><br><span class="line">      total += deepMemoryUsageOf0(instr,counted, o, referenceFilter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">longdeepMemoryUsageOf0</span><span class="params">(Instrumentation instrumentation, Set&lt;Integer&gt; counted,Object obj, VisibilityFilter filter)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SecurityException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Stack&lt;Object&gt; st = <span class="keyword">new</span> Stack();</span><br><span class="line">    st.push(obj);</span><br><span class="line">    <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">while</span> (!st.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">      Object o = st.pop();</span><br><span class="line">      <span class="keyword">if</span> (counted.add(Integer.valueOf(System.identityHashCode(o))))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">long</span> sz =instrumentation.getObjectSize(o);</span><br><span class="line">        total += sz;</span><br><span class="line">       </span><br><span class="line">        Class clz = o.getClass();</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">        Class compType =clz.getComponentType();</span><br><span class="line">        Object localObject1;</span><br><span class="line">        Object localObject2;</span><br><span class="line">        Object el;</span><br><span class="line">        <span class="keyword">if</span> ((compType != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">          (!compType.isPrimitive()))</span><br><span class="line">        &#123;</span><br><span class="line">          Object[] arr = (Object[])o;</span><br><span class="line">          Object[] arrayOfObject1 =arr;localObject1 = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (localObject2 = arrayOfObject1.length; localObject1 &lt;localObject2; localObject1++)</span><br><span class="line">          &#123;</span><br><span class="line">            el = arrayOfObject1[localObject1];</span><br><span class="line">            <span class="keyword">if</span> (el != <span class="keyword">null</span>) &#123;</span><br><span class="line">              st.push(el);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (clz != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">for</span> (Field fld :clz.getDeclaredFields())</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = fld.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (((mod &amp; <span class="number">0x8</span>) == <span class="number">0</span>)&amp;&amp; (isOf(filter, mod)))</span><br><span class="line">            &#123;</span><br><span class="line">              Class fieldClass = fld.getType();</span><br><span class="line">              <span class="keyword">if</span> (!fieldClass.isPrimitive())</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fld.isAccessible()) &#123;</span><br><span class="line">                  fld.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                  Object subObj = fld.get(o);</span><br><span class="line">                  <span class="keyword">if</span> (subObj != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    st.push(subObj);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalAccessExceptionillAcc)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Couldn'tread "</span> + fld);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          clz = clz.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isOf</span><span class="params">(VisibilityFilterf, <span class="keyword">int</span> mod)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (f)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> ALL:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">case</span> PRIVATE_ONLY:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">case</span> NONE:</span><br><span class="line">      <span class="keyword">return</span> (mod &amp; <span class="number">0x2</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> NON_PUBLIC:</span><br><span class="line">      <span class="keyword">return</span> (mod &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> newIllegalArgumentException(<span class="string">"Illegal filter "</span> + mod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最主要的方法是deepMemoryUsageOf0(Instrumentation instrumentation,Set<integer> counted, Object obj, VisibilityFilter filter)<br>这个方法的主要的工作是对一个对象的域进行深度遍历，获取最底层的每个对象的大小，然后加起来。<br>到这里，Instrumentation的所有的功能就完事了，其实就是两个，一个获取对象的大小，一个是作为一个服务，在JVM中的类被定义之前修改类的字节码，跟Spring的AOP不仅形似而且神似。<br>上边的两个Example的代码分别来自于：<br><a href="http://blog.csdn.net/ykdsg/article/details/12080071" target="_blank" rel="noopener">http://blog.csdn.net/ykdsg/article/details/12080071</a><br><a href="http://blog.csdn.net/pwlazy/article/details/5109742" target="_blank" rel="noopener">http://blog.csdn.net/pwlazy/article/details/5109742</a></integer></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java ABC</tag>
        <tag>Instument</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Secret: Using an enum to build a State machine</title>
    <url>/posts/1404542518.html</url>
    <content><![CDATA[<p>原文链接：<a href="http://www.javacodegeeks.com/2011/07/java-secret-using-enum-to-build-state.html" target="_blank" rel="noopener">http://www.javacodegeeks.com/2011/07/java-secret-using-enum-to-build-state.html</a><br>作者：Peter Lawrey    译者：陈振阳</p>
<p>最近在读Hadoop#Yarn部分的源码，读到状态机那一部分的时候，感到enmu的用法实在是太灵活了，在给并发编程网翻译一篇文章的时候，正好碰到一篇这样的文章，就赶紧翻译下来，涨涨姿势。</p>
<h1><span id="综述">综述</span></h1><p>Java中的enum比其他的语言中的都强大，这产生了很多令人惊讶的用法。<br>本文中，我将列出Java中的enum的一些特性，然后将这些特性应用到一起构成一个状态机。<br><a id="more"></a></p>
<h1><span id="enum的单例和工具类用法">Enum的单例和工具类用法</span></h1><p>你可以非常简单地用一个enmu构建一个单例或者工具类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Utility &#123;</span><br><span class="line">    ; <span class="comment">// no instances</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="用enum实现一个接口">用enum实现一个接口</span></h1><p>你也可以在一个enum中实现一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">order</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Planets implements Named &#123;</span><br><span class="line">    Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune;</span><br><span class="line">    <span class="comment">// name() is implemented automagically.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ordinal()+<span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="每一个enum实例一个不同的子类">每一个enum实例，一个不同的子类</span></h1><p>你可以重载一个enum实例的方法。这将高效的给以个enum的实例一个自己的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from http://download.oracle.com/javase/1,5.0/docs/guide/language/enums.html</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">  PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125; &#125;,</span><br><span class="line">  MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125; &#125;,</span><br><span class="line">  TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125; &#125;,</span><br><span class="line">  DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do arithmetic op represented by this constant</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="使用一个enum实现一个状态机">使用一个enum实现一个状态机</span></h1><p>用上边的技术你可以做的是创建一个基于状态的enum。</p>
<p>在这个小例子中，一个解析器的状态机处理一个来自一个ByteBuffer的原始的XML。每一个状态都有自己的处理方法，如果没有足够的可用的数据，状态机可以返回来再次获取更多的数据。状态之间的每一次变换都被定义，所有状态的代码在一个enum中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="function">ByteBuffer <span class="title">buffer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">State <span class="title">state</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">state</span><span class="params">(State state)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> true to keep processing, false to read more data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> States implements State &#123;</span><br><span class="line">    XML &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (context.buffer().remaining() &lt; <span class="number">16</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// read header</span></span><br><span class="line">            <span class="keyword">if</span>(headerComplete)</span><br><span class="line">                context.state(States.ROOT);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, ROOT &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (context.buffer().remaining() &lt; <span class="number">8</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// read root tag</span></span><br><span class="line">            <span class="keyword">if</span>(rootComplete)</span><br><span class="line">                context.state(States.IN_ROOT);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    socket.read(context.buffer());</span><br><span class="line">    <span class="keyword">while</span>(context.state().process(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种方式，可以创建一个XML解析器，解析器可以处理10微秒内的数据包。大多数情况下，它跟你需要的一样高效。</p>
<p><strong>Reference</strong>: <a href="http://vanillajava.blogspot.com/2011/06/java-secret-using-enum-as-state-machine.html" target="_blank" rel="noopener">Java Secret: Using an enum to build a State machine</a> from our <a href="https://www.javacodegeeks.com/join-us/jcg" target="_blank" rel="noopener">JCG partner</a> <a href="http://www.blogger.com/profile/17982030676088168612" target="_blank" rel="noopener">Peter Lawrey</a> at the <a href="http://vanillajava.blogspot.com/" target="_blank" rel="noopener">Vanilla Java</a>.</p>
<h1><span id="related-articles">Related Articles</span></h1><p><a href="http://www.javacodegeeks.com/2011/07/low-gc-in-java-use-primitives-instead.html" target="_blank" rel="noopener">Low GC in Java: Use primitives instead of wrappers</a><br><a href="https://www.javacodegeeks.com/2011/06/java-lambda-syntax-alternatives.html" target="_blank" rel="noopener">Java Lambda Syntax Alternatives</a><br><a href="https://www.javacodegeeks.com/2011/05/how-jvm-handle-locks.html" target="_blank" rel="noopener">How does JVM handle locks</a><br><a href="https://www.javacodegeeks.com/2011/04/erlang-vs-java-memory-architecture.html" target="_blank" rel="noopener">Erlang vs Java memory architecture</a><br><a href="https://www.javacodegeeks.com/2011/02/java-forkjoin-parallel-programming.html" target="_blank" rel="noopener">Java Fork/Join for Parallel Programming</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java ABC</tag>
        <tag>Java enum</tag>
      </tags>
  </entry>
  <entry>
    <title>Shared Transaction Resource Pattern Implements Distributed Transactions in Spring without XA</title>
    <url>/posts/3984494298.html</url>
    <content><![CDATA[<h1><span id="概述">概述</span></h1><p><a href="https://www.javaworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html" target="_blank" rel="noopener">Distributed transactions in Spring, with and without XA</a>一文中描述了在Spring中实现分布式事务的7种处理模式；3种基于XA协议，4种特定场景的非XA协议的模式；</p>
<p>共享事务资源模式（Shared Transaction Resource pattern）是四种非XA协议的第一种，其提供了特定场景的多资源事务同步模式；</p>
<p>熟悉Spring 事务框架的看到Transaction Resource应该立马就明白了，Transaction Resource就是JDBC里的Connection对象，Hibernete里的Session对象，以此类比；<br><a id="more"></a><br>像JDBC的Connection，Hibernete的Session等如果要共享，也就意味着两个事务使用的是同一个连接，也就意味着不再有分布式事务一说，两个系统的操作真的是在同一个事务之中。</p>
<h1><span id="orm框架和spring-jdbc">ORM框架和Spring JDBC</span></h1><p>先描述一下文中的两个例子：<br>第一个是ORM框架和JDBC，这是一个好像不是分布式事务的例子，在这里我们描述的更具体一些，将JDBC换乘Spring JDBC，让他看上去更像分布式事务一些，理解这个例子是基础，一定要仔细看看：<br>在基于Spring架构的应用中，如果同时使用了ORM框架Hibernete和Spring JDBC一起操作数据库，那么如何将Spring JDBC的事务和Hibernete的事务进行同步呢？</p>
<p>答案就是共用一个JDBC Connection对象，Spring JDBC封装了Java JDBC，Hibernete也是基于JDBC构建的，也就是说如果在Spring  JDBC 和 Hibernete中使用同一个Java JDBC Connection对象，就可以实现事务的同步，其实根本就是在一个JDBC 事务中。</p>
<h1><span id="消息驱动的单个数据库更新">消息驱动的单个数据库更新</span></h1><p>文中提到共享事务资源模式的典型应用场景是<strong>消息驱动的单个数据库更新</strong>。这是一个看上去就需要分布式事务同步场景。</p>
<h2><span id="基于activemq实现消息驱动的单个数据库更新场景">基于ActiveMQ实现消息驱动的单个数据库更新场景</span></h2><p>文中同时举了一个ActiveMQ + JDBC的例子，ActiveMQ是JMS协议的实现，同时ActiveMQ支持可配置的消息存储的，其中就可以将ActiveMQ的队列中的消息存储到关系型数据库中。</p>
<p>当把ActiveMQ把消息存储到关系型数据库中之后，如果我们后续的消息的业务处理之后的结果，也写到同一个数据库中，那ActiveMQ中消息的更新和业务系统中消息的处理结果持久化就可以共用一个数据库连接了。</p>
<p>可以共用一个数据库连接，也就意味着不再牵扯到分布式事务；</p>
<h2><span id="基于kafka实现消息驱动的单个数据库更新场景">基于Kafka实现消息驱动的单个数据库更新场景</span></h2><p>这里在送大家一个特定的例子，基于Kafka实现消息驱动的单个数据库更新的场景。上边的例子有着很大的性能问题，而基于Kafka实现消息驱动的单个数据库更新的场景就像是天造地设一般。</p>
<p>Kafka消息队列里的读取进度是存储在Consumer端的，在Kafka中，叫做Offset。也就是说，如果我们在拉取消息之后，将最新的offset和消息的处理结果，共用同一个事务资源，写到一个地方，要么一起成功，要么一起失败；如果发生Partition的重新分配，只需要从存储中读取最近一次成功处理的那批消息的最大的offfset，然后让Consumer，seek此offset即可。实际上Kafka Connect的很多实现，比如Kafka Connect HDFS就是这么搞的。</p>
<p>这里描述一个具体的例子，Kafka + 关系型数据库：</p>
<h1><span id="参考">参考</span></h1><p><a href="https://www.javaworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html" target="_blank" rel="noopener">Distributed transactions in Spring, with and without XA</a><br><a href="http://www.importnew.com/15812.html" target="_blank" rel="noopener">如何实现XA式、非XA式Spring分布式事务</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Transaction</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Transaction</tag>
        <tag>Distributed Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Message Delivery Semantics</title>
    <url>/posts/3775642630.html</url>
    <content><![CDATA[<h1><span id="kafka-消息交付delivery语义">Kafka 消息交付（Delivery）语义</span></h1><p>Kafka的消息交付语义有三种，At most once、At least once和Exactly once，它们的官方解释如下：</p>
<ul>
<li>At most once—Messages may be lost but are never redelivered.</li>
<li>At least once—Messages are never lost but may be redelivered.</li>
<li>Exactly once—this is what people actually want, each message is delivered once and only once.<a id="more"></a>
<h2><span id="once的意义">Once的意义</span></h2>上面提到的Kafka的三种消息交付语义的知识点已经烂大街了，但是这里的once指的意义，需要进一步明确一下；<br>这里的Once的指的不是消息接收到的次数，而是指的在没有抛出阻碍给Kafka Server反馈Offset的异常的情况下，成功处理一条消息的次数。</li>
</ul>
<p>这里需要说明两个情况，第一个是消息处理逻辑幂等，第二个是消息处理逻辑抛出没有阻碍给Kafka Server反馈Offset的异常。</p>
<h2><span id="消息处理逻辑幂等">消息处理逻辑幂等</span></h2><p>微服务火起来之后，幂等这个词也跟着火起来了，微服务的环境中，大多数的服务都需要考虑幂等设计。那这里需要明确的是，同一条消息，被一个幂等设计的处理逻辑接收到多次，那么这条消息是相当于被处理了一次还是多次呢？<br>没错，是被处理了多次，而且是相当于被成功处理了多次。<br>对于Kafka来说，不管你的处理逻辑是否幂等，那消息处理的模式都是接收消息-&gt;处理消息-&gt;提交Offset，这三个步骤，消息走完一遍即是被成功处理了一次，不管处理消息这一步是否是幂等的。</p>
<h2><span id="消息处理逻辑抛出没有阻碍给kafka-server反馈offset的异常">消息处理逻辑抛出没有阻碍给Kafka Server反馈Offset的异常</span></h2><p>消息处理失败并不是简单的指的程序抛出异常，而是这个异常一定要阻碍了后续给Kafa Server 反馈Offset才算处理失败。比如说，接收到消息之后，业务处理逻辑在处理的过程中，抛出一个InvalidUserNameException，很明显，这是一个业务级别的异常。这个异常虽然在此处被抛出去，但是整个应用中，一定有一个地方会处理这个异常，比如说简单的记录日志，或者将此消息发送到一个特定的kafka topic，由另外的逻辑来处理。<br>这里需要注意的是，从上面的处理过程来看，我们完美的处理了这个消息，这个消息虽然不合法，但是我们也处理了不合法的情况，所以这条消息，对于Kafka Server来说，我们是成功处理了，没有必要再让Kafka Server重新发送一次此消息了。所以在处理完InvalidUserNameException异常之后，我们应该提交Offset给Kafka Server，告诉Kafka Sever，我们成功消费了这条消息。</p>
<p>在使用Spring Kafka时，其提供了一个类似的特性，消息在处理失败达到指定的最大次数的时候，会将其发送到一个dead-letter topic，然后commit offset，即是这样的情况。这是Spring Kafka框架替我们做的recover机制，对于Kafka Server来说，这条消息被成功处理了，并且收到了KafkaConsumer Commit的Offset。</p>
<p>在Spring Kafka 中存在一个ErrorHandler组件，可以配置到@KafkaListener注解上。配置当Listener出错时，可以使用指定的ErrorHandler来处理失败，在ErrorHandler中，我们可以拿到抛出的异常对象，当前正在处理的消息对象和Consumer对象，我们可以根据异常的类型和消息对象提供的信息，来灵活的判断是否需要使用Consumer提交offset。</p>
<p>其反面的就是像数据库连接失败，数据库死锁等的异常，如果消息处理过程中，出现了此类异常，只能重传了。</p>
<h2><span id="消息交付语义是指的producer发送消息还是指的consumer接收消息">消息交付语义是指的Producer发送消息还是指的Consumer接收消息？</span></h2><p>KafkaProducer在发送消息时，可能会重复发送，Consumer接收处理消息时，如果过早的提交offset，可能会导致消息处理失败，无法提交offset，而再次接收到同一条消息。</p>
<p>那么，消息交付语义是指的Producer发送消息还是指的Consumer接收消息呢？显然都不是，而是指的在Producer和Consumer的配合下，实现消息被成功处理的次数的可能的情况。</p>
<p>比如At most once，就是指的在Producer和Consumer的配合下，消息最多会被成功处理一次。看上面可以理解成功处理的意义。举个例子,BS=Business Service：</p>
<p>Kafka Topic1-&gt;BS1-Kafka Topic2-&gt;BS2-Kafka Topic3-&gt;BS3-&gt;Kafka Topic4-&gt;DB</p>
<p>上面的例子，在3个BS处，都是Receive-Process-Produce模式，如果我们在3个BS处的KafkaConsumer都可能会重复收到消息，KafkaProducer对象都可能会重复发送消息，那么在DB处就可能会出现重复的结果。另外两个Kafka交付语义类似。</p>
<h1><span id="kafka-消息交付delivery语义配置">Kafka 消息交付（Delivery）语义配置</span></h1><p>KafkaProducer相关配置参数：acks、retries、enable.idempotence、max.in.flight.requests.per.connection<br>KafkaConsumer相关配置参数：enable.auto.commit、auto.commit.interval.ms、isolation.level</p>
<h1><span id="kafka-client-api">Kafka Client API</span></h1><figure class="highlight java"><figcaption><span>KafkaProducer</span></figcaption><table><tr><td class="code"><pre><span class="line">KafkaProducer</span><br><span class="line">initTransactions</span><br><span class="line">beginTransaction</span><br><span class="line">sendOffsetsToTransaction</span><br><span class="line">commitTransaction</span><br><span class="line">abortTransaction</span><br></pre></td></tr></table></figure>
<p>KafkaProducer事务API用来保证在Receive-Process-Produce模式中，Produce数据到Kafka Topic时的EOS语义的；<br>at most once 和 at least once的实现不用KafkaProducer事务API；只需要配置上述相关参数，处理好消息的业务处理和offset保存的先后顺序即可。</p>
<pre><code>KafkaConsumer
commitSync
commitAsync
</code></pre><p>如果设置了consumer自动提交之后，也就是enable.auto.commit和auto.commit.interval.ms，则consumer每隔auto.commit.interval.ms自动commit；</p>
<h1><span id="kafka-消息交付delivery语义实现">Kafka 消息交付（Delivery）语义实现</span></h1><h2><span id="at-most-once-实现">At most once 实现</span></h2><p>通过禁用 producer 的重传功能和让 consumer 在处理一批消息之前提交 offset，实现 at-most-once 的消息交付<br>KafkaProducer：禁用幂等，关闭重传；acks=0或1，ack0失败的概率最高， ack1也有可能失败；acks=0时retries配置实效；enable.idempotence=false，默认fase；<br>KafkaConsumer：consumer 在处理一批消息之前提交 offset；可以enable.auto.commit=true+auto.commit.interval.ms较小值，或者手动KafkaConsuer#commitSync()</p>
<h2><span id="at-least-once-实现">At least once 实现</span></h2><p>Kafka 默认保证 at-least-once 的消息交付。<br>KafkaProducer：禁用幂等，开启重传；acks=all；acks配置较大数值；enable.idempotence=false，默认fase；<br>KafkaConsumer：consumer 在处理一批消息之后提交 offset；关闭自动提交，处理完消息之后手动commit；</p>
<h2><span id="exactly-once-实现">Exactly once 实现</span></h2><p>KafkaProducer：开启幂等；启动幂等之后，kafka client自动将retries设置大于0，all=all；启用幂等，即可保证正好一次；如果是发送给多个topics，配置transactional.id，使用Producer事务API开启事务，即可保证同一个事务中的消息只发送成功一次；启动幂等之后，max.in.flight.requests.per.connection需要设置小于等于5；<br>KafkaConsumer：正好被成功处理一次的思路是，保存offset的操作和业务逻辑放到一个事务中；</p>
<p>正好一次的典型应用场景是Receive-Process-Produce，将这三个操作，放到一个事务中，要么一起成功，要么一起失败；</p>
<p>这里列举两个具体场景：<br>在Receive-Process-Produce，如果最后的Produce是生产数据到外部系统，则将offset保存这个外部系统中，使用外部系统的事务，将Produce的数据和Offset放到一个外部系统的事务中，一起提交。比如使用关系型数据库，则可以使用JDBC事务实现；Kafka Connect就是使用这种方法，保证数据只被导出一次的。Kafka Streams中，典型的应用场景是最终将数据导出到非Kafka系统，此时使用的就是Kafka Connect。</p>
<p>在Receive-Process-Produce，如果是发送到另一个Kafka Topic，则使用KafkaProducer的事务API 将Offset的保存（offset被保存在kafka的内置的_consumer_offset中）和Producer发送放到一个事务中；Kafka Streams里所有中间Processor节点的输入输出都是Kafka Topic，其就是使用这个机制保证的Kafka Stream所有中间Processor处的消息的EOS；使用事务性KafkaProducer提供 整个Stream上exactly-once 的消息交付能力。</p>
<blockquote>
<p>由于Zookeeper并不适合大批量的频繁写入操作，新版Kafka已推荐将consumer的位移信息保存在Kafka内部的topic中，即__consumer_offsets topic，并且默认提供了kafka_consumer_groups.sh脚本供用户查看consumer信息。</p>
</blockquote>
<p>在Receive-Process-Produce模式中，其实消息Process之后，Produce到Kafka Topic还是发送到其他拥有事务管理能力的外部系统，是一个处理思路，都是用将offset的保存和外部系统的事务放在一起。</p>
]]></content>
      <categories>
        <category>Apache Kafka</category>
      </categories>
      <tags>
        <tag>Apache Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Retry Framework Stateful Retry</title>
    <url>/posts/10764762.html</url>
    <content><![CDATA[<p>Spring Retry中的重试，分为无状态的重试和有状态的重试；</p>
<h1><span id="简述">简述</span></h1><p>有状态重试通常是用在message-driven 的应用中，从消息中间件比如RabbitMQ等接收到的消息，如果应用处理失败，那么消息中间件服务器会再次投递，再次投递时，对于集成了Spring Retry的应用来说，再次处理之前处理失败的消息，就是一次重试；也就是说，Spring Retry能够识别出，当前正在处理的消息是否是之前处理失败过的消息；<br><a id="more"></a><br>如果是之前处理过的消息，Spring Retry就可以使用 back off policies 阻塞当前线程；Spring Retry同时追踪重试的次数，支持处理彻底失败后的recover，这也是使用有状态重试的理由；</p>
<p>有状态重试的另一个典型应用场景是跟Spring Transaction框架集成。在集成了Spring Transaction框架的MVC应用中，通过TransactionInterceptor，开启对Service层的事务管理；在这种情况下，Spring Retry会提供让每一次重试和重试次数耗尽之后的recover都在一个新的事务中执行。</p>
<h1><span id="举个栗子">举个栗子</span></h1><p><a href="https://github.com/58greenwhale/spring-retry-samples.git" target="_blank" rel="noopener">spring-retry-samples</a></p>
<h1><span id="参考">参考</span></h1><p><a href="https://stackoverflow.com/questions/54559143/spring-retryable-with-stateful-hibernate-object" target="_blank" rel="noopener">Spring @Retryable with stateful Hibernate Object</a><br><a href="https://stackoverflow.com/questions/38212471/springboot-retryable-not-retrying" target="_blank" rel="noopener">Springboot @retryable not retrying</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Retry Framework</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Retry Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>The Perfect Singleton</title>
    <url>/posts/3384101157.html</url>
    <content><![CDATA[<p>我不时遇到那些事实上不确定他们应该如何合适地实现单例模式的Java程序员。<br>我不考虑在线程的环境中合适的实现。但是使用你能在网络上找到的大多数常见的实现方式，你可以轻松地创建你想要的多种单例实现。<br><a id="more"></a><br>假设你有下面这种常见的单例的实现：<br><figure class="highlight java"><figcaption><span>NonSafeSingletonimplements</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonSafeSingletonimplements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NonSafeSingleton INSTANCE = <span class="keyword">new</span> NonSafeSingleton();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">NonSafeSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NonSafeSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，注意到Serializable 这个单词。思考一会…..你是对的。如果通过RMI发送上边的代码，你将会得到第二个实例。它应该足够可以做一些内存中的序列化和反序列化操作。你刚刚违反了单例的规则。那不是很好。但是如何修复它？通常我会用两种方式：</p>
<h1><span id="困难的方式如果你用java14或者更老的版本">困难的方式（如果你用Java1.4或者更老的版本）</span></h1><p>你需要在你的单例类中实现一个readResolve方法。这通常用来重写序列化机制已经创建的内容。在这个方法里返回的是用来代替来自序列化的数据。这里仅需要返回你的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="简单的方式如果你用java15或更新的版本">简单的方式（如果你用Java1.5或更新的版本）</span></h1><p>将你的单例类改成枚举类型，然后移除私有构造方法和getInstance方法。下面，真的很简单。然后你将免费得到下面这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SafeSingleton implements Serializable &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你再实现单例模式时，记住这些。如果你大量的使用RMI,它可以使你的生活更加简单。</p>
<p><strong>Reference</strong>: <a href="https://jdevel.wordpress.com/2010/10/02/the-perfect-singleton/" target="_blank" rel="noopener">The Perfect Singleton</a> fromour <a href="https://www.javacodegeeks.com/join-us/jcg" target="_blank" rel="noopener">JCG partner</a> MarekPiechut at the <a href="https://jdevel.wordpress.com/" target="_blank" rel="noopener">Development worldstories</a>.</p>
<h1><span id="related-articles">Related Articles</span></h1><p><a href="https://www.javacodegeeks.com/2011/03/dreaded-double-checked-locking-idiom-in.html" target="_blank" rel="noopener">The dreaded double checked locking idiom in Java</a><br><a href="https://www.javacodegeeks.com/2011/07/java-secret-using-enum-to-build-state.html" target="_blank" rel="noopener">Java Secret: Using an enum to build a State machine</a><br><a href="https://www.javacodegeeks.com/2010/12/dependency-injection-manual-way.html" target="_blank" rel="noopener">Dependency Injection – The manual way</a><br><a href="https://www.javacodegeeks.com/2011/04/java-generics-quick-tutorial.html" target="_blank" rel="noopener">Java Generics Quick Tutorial</a><br><a href="https://www.javacodegeeks.com/2011/05/how-jvm-handle-locks.html" target="_blank" rel="noopener">How does JVM handle locks</a></p>
<h1><span id="译者注">译者注</span></h1><p>这篇文章在并发编程网发出来的时候，下面有几个比较重要的评论在这粘贴一下，也给大家一点启发：</p>
<h2><span id="评论1">评论1</span></h2><p>如果考虑线程的情况下，这种单例是我见过最好的了 initialization-on-demand holder idiom<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInitiOnDemand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonInitiOnDemand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonInitiOnDemand INSTANCE = <span class="keyword">new</span> SingletonInitiOnDemand();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonInitiOnDemand <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回答：<br>厉害，查了一下，这种方式巧妙地利用内部类的机制实现了延时加载和线程安全。</p>
<h2><span id="评论2">评论2</span></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SafeSingleton implements Serializable &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您能把这段代码的实现原理机制说一下吗？<br>代码里不需要new 一个INSTANCE 实例吗？比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NonSafeSingleton INSTANCE = <span class="keyword">new</span> NonSafeSingleton;</span><br></pre></td></tr></table></figure>
<p>回答：<br>这段代码的原理机制，就是enmu的原理机制。enmu对象是不需要new的。我下面写一个例子你就明白了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> SafeSingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(“t”);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Testt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SafeSingleton singleton = SafeSingleton.INSTANCE;</span><br><span class="line">    singleton.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家也可以在并发编程网查看更多的评论 <a href="http://ifeve.com/perfect-singleton/" target="_blank" rel="noopener">http://ifeve.com/perfect-singleton/</a></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Using the State pattern in a Domain Driven Design</title>
    <url>/posts/3262808649.html</url>
    <content><![CDATA[<p>领域驱动设计是软件开发的一种方式，问题复杂的地方通过将具体实现和一个不断改进的核心业务概念的模型连接解决。这个概念是Eric Evans提出的，<a href="http://www.domaindrivendesign.org/" target="_blank" rel="noopener">domaindrivendesign</a>这个网站来促进领域驱动设计的使用。关于领域驱动设计的定义，<a href="http://dddcommunity.org/resources/ddd_terms/" target="_blank" rel="noopener">dddcommunity</a>，这个网站有很多的描述，DDD是一种软件开发的方式：<br><a id="more"></a></p>
<ol>
<li>对于大多数的软件项目，主要的精力应该在领域和领域的逻辑。</li>
<li>复杂的领域设计应该基于一个模型。</li>
</ol>
<p>DDD促进了技术和领域专家之前的创造性的合作，迭代地接近问题的概念核心。注意，在没有领域专家的帮助时，一个技术专家可能不会完全理解领域的错综复杂，当然，没有技术专家的帮助，一个领域专家实际上也不能应用它的知识到项目中。</p>
<p>大多数情况下，一个领域模型对象封装一个内部的状态，本质上是一个系统中某个元素的历史，也就是，对象的操作是有状态的。在那种情况下，对象保持它的私有状态，这个状态最终将影响他的行为。状态设计模式可以干净地代表一个对象的状态，处理它的状态转换。简而言之，状态模式是针对依赖于状态做出行为的问题的解决方案。</p>
<p>很明显,DDD和状态设计模式息息相关。我对DDD是个新手，所以我将让我们最出色的JCG伙伴Tomasz Nurkiewicz，用一个例子来介绍使用状态设计模式的DDD。</p>
<p>注意：为了提高可读性，原始邮件被稍微重新编辑了下。</p>
<p>一些企业应用中的领域对象包含状态的概念。状态有两个主要的特性：</p>
<ol>
<li>领域对象的表现（如何响应业务方法）依赖于它的状态。</li>
<li>业务方法可能改变对象的状态，在一个特定的调用之后，对象可能表现出不同的行为。</li>
</ol>
<p>如果你不能想象任何领域对象的例子，想象在租赁公司的一个Car实体。这个Car，尽管是同一个对象，但是它有一个附加的状态标识，这对公司来说至关重要。这个状态标识可能有三个值：</p>
<ol>
<li>AVAILABLE</li>
<li>RENTED</li>
<li>MISSING</li>
</ol>
<p>很明显，当一个Car处于RENTED或者MISSING的时候，是不能被租出去的，rent()方法应该失效。但是当Car被还回来的时候，它的状态时AVALIABLE，对这个Car实体调用rent()方法应该与之前租借这个Car的用户无关，将车的状态改为RENTED。状态标识（可能是一个字符或者是数据库中的int类型）是对象状态的一个例子，因为它影响着业务方法，反之亦然，业务方法也可以改变状态。</p>
<p>现在，思考一个问题，你将怎么实现这个场景，我相信，这个场景你在工作中遇到过很多次了。你有很多依赖于当前的状态的业务方法和很多种的状态。如果你喜欢面向对象编程，你可能立即想到继承然后创建一个继承自Car的AvailableCar，RentedCar和MissingCar。这看上去很好，但是不切实际地，特别是当Car是一个持久化对象的时候。实际上，这种继承的方式不是一种好的设计：我们想要的不是改变整个对象，仅仅是对象的一条内部状态，也就是说，我们不会替换一个对象，仅仅是改变它。也许你想在每一个依赖于状态执行不同的任务的方法中用if-else-if-else这种层叠的方式。。。不要这么做，相信我，那是代码维护的地狱。</p>
<p>相反，我们将不使用继承和多态，但这是一个更聪明的方式：使用状态模式。举个例子，我选择了一个叫做Reservation的实体，这个实体有下面这些状态。</p>
<p>这个生命周期是非常简单的“当Reservation被创建，它是NEW状态。然后一些被授权的人可以接受这个Reservation，导致像座位被短暂地保留的事件发生，然后给人发送一个e-mail，让其为Reservation付费。再然后，用户执行转账，钱到账，打印票据，然后发送第二封邮件给客户。</p>
<p>你肯定已经意识到一些动作依据Reservation 当前的状态有不同的效果。例如，你可以在任意时间取消reservation，但是依赖于Reservation当前的状态，取消动作可能导致退款然后取消reservation，或者仅仅是发送给用户一个e-mail。一些动作不依赖于特定的状态（如果用户为一个已经取消的reservation付账会怎么样）或者应该被忽略。如果你在每个状态和每个业务方法中用了if-else结构，现在想象一下依据上边的状态机写出业务方法将有多难。</p>
<p>为了解决这个问题，我将不解释原始的GoF状态设计模式。而是介绍一些在使用了java ENUM的功能之后，我对这个设计模式的一些改变的地方。代替为状态抽象创建一个抽象的类或接口，然后为每一个状态写实现这种方式，我简单的创建一个包含了所有可用的状态的enum。</p>
<figure class="highlight java"><figcaption><span>ReservationStatus</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ReservationStatus &#123;</span><br><span class="line"> NEW,</span><br><span class="line"> ACCEPTED,</span><br><span class="line"> PAID,</span><br><span class="line"> CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我为所有依赖于状态的业务方法创建了一个接口。把这个接口当做所有状态的抽象基类，但是我们将以稍微不同的方式使用它。</p>
<figure class="highlight java"><figcaption><span>ReservationStatusOperations</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReservationStatusOperations</span> </span>&#123;</span><br><span class="line"> <span class="function">ReservationStatus <span class="title">accept</span><span class="params">(Reservationreservation)</span></span>;</span><br><span class="line"> <span class="function">ReservationStatus <span class="title">charge</span><span class="params">(Reservationreservation)</span></span>;</span><br><span class="line"> <span class="function">ReservationStatus <span class="title">cancel</span><span class="params">(Reservationreservation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，Reservation领域对象，恰巧同时也是一个JPA实体（省略getters/setters）。</p>
<figure class="highlight java"><figcaption><span>Reservation</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reservation</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> intid;</span><br><span class="line"> privateString name;</span><br><span class="line"> privateCalendar date;</span><br><span class="line"> privateBigDecimal price;</span><br><span class="line"> privateReservationStatus status = ReservationStatus.NEW;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//getters/setters</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Reservation是一个持久的领域对象，他的状态（ReservationStatus）很明显也应该被持久化。这个观察结果将使我们第一次体会到使用enum代替抽象类的巨大好处：JPA/Hibernate可以很容易地使用enum的名字或者顺序的值（默认）序列化和持久化java enum到数据库中。在原始的GoF模式中，我们将直接把ReservationStatusOperations 对象放到领域对象中，然后状态改变时切换不同的实现。我建议使用enum然后仅改变enum的值。使用enum的另一个优势（不是以框架为中心的但是更重要的）是所有可能的状态在一个地方列出。你不必在你的源码中爬行来寻找所有的状态基类的实现。所有的东西都能在一个地方被看到，一个逗号分隔的列表。</p>
<p>OK，深呼吸。现在我解释一下所有的部分如何在一起工作，ReservationStatusOperations 中的业务操作为什么返回ReservationStatus。首先，你必须回忆一下， enum究竟是什么。他们不仅仅是像C/C++那样的多个常量在一个命名空间下的集合。在JAVA中，enum是多个类的闭集，继承自一个公共的基类（例如ReservationStatus），最后继承自enum类。所以当使用enum的时候，我们可能就使用了多态和继承。</p>
<figure class="highlight java"><figcaption><span>ReservationStatus</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ReservationStatus implements ReservationStatusOperations &#123;</span><br><span class="line"></span><br><span class="line">  NEW &#123;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">accept</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">charge</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">cancel</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ACCEPTED &#123;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">accept</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">charge</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">cancel</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  PAID &#123;<span class="comment">/*...*/</span>&#125;,</span><br><span class="line"></span><br><span class="line">  CANCELLED &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然以上边的方式写一个ReservationStatusOperations 类很容易，但是从长远来看，这是一个坏主意。不仅enum源代码会极其的长（所有要实现的方法的数量等于状态的数量乘以业务方法的数量），而且是一个坏的设计（所有状态的业务逻辑在一个类中）。一个enum也可以实现一个接口，这个奇特的语法可能与没有参加过SCJP exam 考试的人的直觉相反。我们将提供一个简单的中间层，因为计算机科学中的任何问题都可以被另一个中间层解决。</p>
<figure class="highlight java"><figcaption><span>ReservationStatus</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ReservationStatus implementsReservationStatusOperations &#123;</span><br><span class="line"> </span><br><span class="line">  NEW(newNewRso()),</span><br><span class="line">  ACCEPTED(newAcceptedRso()),</span><br><span class="line">  PAID(newPaidRso()),</span><br><span class="line">  CANCELLED(<span class="keyword">new</span> CancelledRso());</span><br><span class="line"> </span><br><span class="line">  privatefinal ReservationStatusOperations operations;</span><br><span class="line"> </span><br><span class="line">  ReservationStatus(ReservationStatusOperationsoperations) &#123;</span><br><span class="line">    <span class="keyword">this</span>.operations = operations;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">publicReservationStatus <span class="title">accept</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    returnoperations.accept(reservation);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">publicReservationStatus <span class="title">charge</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    returnoperations.charge(reservation);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">publicReservationStatus <span class="title">cancel</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    returnoperations.cancel(reservation);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们的ReservationStatus enum的最终的源代码（实现ReservationStatusOperations 不是必须的）。把事情变简单：每一个enum值都自己特定的ReservationStatusOperations 实现（简写为Rso）。ReservationStatusOperations 的实现作为构造函数的参数，然后赋给一个命名为operations的final类型的域。现在，不管enum中的业务方法什么时候被调用，调用将被委托给特定的ReservationStatusOperations 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReservationStatus.NEW.accept(reservation);       <span class="comment">// will call NewRso.accept()</span></span><br><span class="line">ReservationStatus.ACCEPTED.accept(reservation);  <span class="comment">// will call AcceptedRso.accept()</span></span><br></pre></td></tr></table></figure>
<p>最后一个要实现的部分是包含业务方法Reservation领域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setStatus(status.accept(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setStatus(status.charge(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setStatus(status.cancel(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(ReservationStatus status)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (status!= <span class="keyword">null</span> &amp;&amp; status != <span class="keyword">this</span>.status) &#123;</span><br><span class="line">    log.debug(<span class="string">"Reservation#"</span> + id + <span class="string">": changing status from"</span> + <span class="keyword">this</span>.status+ <span class="string">" to "</span> + status);</span><br><span class="line">    <span class="keyword">this</span>.status = status;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里发生了什么？当你在一个Reservation领域对象实例上调用任何业务方法，ReservationStatus  enum的某个值的相应的方法就会被调用。依据当前的状态，一个不同的方法（不同ReservationStatusOperations 实现的）将会被调用。但是没有switch-case 和if-else结构，仅仅使用了多态。例如，如果当status域指向ReservationStatus.ACCEPTED，你调用了charge()方法，AcceptedRso.charge() 将会被调用，消费者将会被要求付款，付款之后，Reservation状态改变成PAID。</p>
<p>但是如果我们在同一个实例再次调用charge()会发生什么？status域现在指向ReservationStatus.PAID，所以PaidRso.charge() 将会被执行，这将会抛出一个业务错误（为一个已付款的Reservation付款是无效的）。没有条件判断的代码，我们实现了一个业务方法状态敏感的领域对象。</p>
<p>我还没有提到的一件事是如何从一个业务方法改变Reservation的状态。这是与原始的GoF模式第二个不同的地方。我从业务方法简单的返回一个新的状态，而不是传递一个StateContext 实例给每一个状态敏感的操作（像accept()或者charge()方法），这种方式经常被用来改变状态。如果给定的状态不是null而且与先前的状态不同（setStatus方法中实现），Reservation对象将转变为给定的状态。让我们看一下在AcceptedRso 对象中是如何工作的（Reservation对象在ReservationStatus.ACCEPTED 状态，它的方法将要被执行）。</p>
<figure class="highlight java"><figcaption><span>implementsReservationStatusOperations</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcceptedRso</span> <span class="title">implementsReservationStatusOperations</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">publicReservationStatus <span class="title">accept</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">throw</span> newUnsupportedStatusTransitionException(<span class="string">"accept"</span>,ReservationStatus.ACCEPTED);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">publicReservationStatus <span class="title">charge</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//chargeclient's credit card</span></span><br><span class="line">    <span class="comment">//sende-mail</span></span><br><span class="line">    <span class="comment">//printticket</span></span><br><span class="line">    returnReservationStatus.PAID;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">   <span class="function">publicReservationStatus <span class="title">cancel</span><span class="params">(Reservation reservation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//sendcancellation e-mail</span></span><br><span class="line">     returnReservationStatus.CANCELLED;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ACCEPTED 状态的Reservation 可以通过上边的类源码很容易地理解：当一个Reservation已经被accept时，试图accept第二次将会跑出一个错误，收费将使用客户的信用卡，打印给他一个票据然后发送一个email等等。同时，付费操作将返回一个PAID状态，这将使Reservation转换成这个状态。这意味着第二次调用charge将被不同的ReservationStatusOperations 实现处理（PaidRso），没有条件判断。</p>
<p>上边是关于状态模式的全部。如果你不相信这种设计模式，比较一下使用条件判断的代码这种传统的方式的工作量和容易出错的代码。</p>
<p>我没有展示所有的ReservationStatusOperations 的实现，但是如果你将在基于JavaEE的String或者EJB中引入这种方式，你可能已经看到一个弥天大谎。我描述了每一个业务方法应该发生的事情，但是没有提供具体的实现。我没有的原因是因为我遇到了一个大问题：一个Reservation实例通过手工（用new）或者持久化框架像hibernate创建。 It uses statically created enum which creates manuallyReservationStatusOperations implementations.没有办法去注入依赖，DAOs和service.对于这个类来说，它的整个生命周期都在spring或者ejb的容器管辖之外。实际上，有一个简单有效的解决方案，使用Spring和AspectJ。但是耐心点，我将在下一封邮件中详细的解释，如何给应用增加一点领域驱动的味道。</p>
<p>就这样。一个非常有趣的邮件，解释了如何在DDD方式中使用状态模式，作者是我们的JCG伙伴，Tomasz Nurkiewicz.。我非常期待这个教程的下一个部分。下一个部分是：Domain Driven Design with Spring and AspectJ.</p>
<p><strong>Related Articles:</strong><br><a href="https://www.javacodegeeks.com/2011/02/domain-driven-design-spring-aspectj.html" target="_blank" rel="noopener">Domain Driven Design with Spring and AspectJ</a><br><a href="https://www.javacodegeeks.com/2011/01/spring-configuration-zero-xml.html" target="_blank" rel="noopener">Spring configuration with zero XML</a><br><a href="https://www.javacodegeeks.com/2011/01/10-tips-proper-application-logging.html" target="_blank" rel="noopener">10 Tips for Proper Application Logging</a><br><a href="https://www.javacodegeeks.com/2010/12/things-every-programmer-should-know.html" target="_blank" rel="noopener">Things Every Programmer Should Know</a><br><a href="https://www.javacodegeeks.com/2010/12/dependency-injection-manual-way.html" target="_blank" rel="noopener">Dependency Injection – The manual way</a></p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos上ShadowSocks搭建Socket5服务器</title>
    <url>/posts/3396596425.html</url>
    <content><![CDATA[<p>买的VPN最近好像跑路了，看了下阿里云的国外ECS，超便宜，美国西部做活动一年才300多RMB；</p>
<p>Shadowsock是一个安全的socks5代理软件，提供了服务端和客户端；可以很方便的搭建一个VPN；</p>
<h1><span id="服务器端搭建">服务器端搭建</span></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget –no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">$ ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>
<p>安装成功会显示如下的信息，将下面的信息填写到客户端里面就可以了；<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Starting Shadowsocks success</span><br><span class="line"></span><br><span class="line">Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        :  47.88.56.208 </span><br><span class="line">Your Server Port      :  8989</span><br><span class="line">Your Password         :  xxxx </span><br><span class="line">Your Encryption Method:  rc4-md5</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/342.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure></p>
<h1><span id="客户端配置">客户端配置</span></h1><p><img src="![](https://54architect.oss-cn-beijing.aliyuncs.com/blog.54architect.com/2019-03-21 15-06-37 的屏幕截图.png" alt="image"><br>)</p>
<p>这里需要特别注意的是，有些socks5客户端提供了将socks5转为http(s)的功能，这里要选则socks5。</p>
<h1><span id="privoxy配置">Privoxy配置</span></h1><p>Privoxy可以将socks5转为http(s)协议；<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">forward-socks5   /               127.0.0.1:1080 .</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install privoxy </span><br><span class="line">//开启privoxy 服务就行</span><br><span class="line">sudo  service  privoxy start </span><br><span class="line">// 设置http 和 https 全局代理</span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">'http://localhost:8118'</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">'https://localhost:8118'</span></span><br><span class="line">// 测试一下</span><br><span class="line">wget https://www.google.com</span><br></pre></td></tr></table></figure>
<h1><span id="参考">参考</span></h1><p><a href="https://blog.csdn.net/li740207611/article/details/52045471" target="_blank" rel="noopener">使用Privoxy将socks5代理转为http代理</a><br><a href="https://blog.csdn.net/yanzi1225627/article/details/51064306" target="_blank" rel="noopener">Mac上Privoxy将shadowsocks的socks5代理转为http代理(解决SublimeText无法安装插件的问题)</a></p>
]]></content>
      <categories>
        <category>Nuclear</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Centos</tag>
        <tag>ShadowSocks</tag>
        <tag>Socks5</tag>
        <tag>Privoxy</tag>
      </tags>
  </entry>
</search>
